#!/usr/bin/env python2

from __future__ import print_function
import sys
import subprocess
import collections
from distutils.spawn import find_executable

class PreHook:
    """Constructor for PreHook class"""
    def __init__(self, hookconfig):
        self.warnfiles = hookconfig['warnfiles']

        self.linter = hookconfig['linter']['executable']
        self.lintext = hookconfig['linter']['extension']
        self.lintargs = hookconfig['linter']['arguments']

        self.tester = hookconfig['testing']['executable']
        self.testargs = hookconfig['testing']['arguments']
        self.testoutput = hookconfig['testing']['testoutput']

        self.checks = hookconfig['checks']
        self.exitstatus = True

        self.red = '\033[91m'
        self.redbold = '\033[1;91m'
        self.yellow = '\033[93m'
        self.green = '\033[92m'
        self.greenbold = '\033[1;92m'
        self.blue = '\033[94m'
        self.bluebold = '\033[1;94m'
        self.resetc = '\033[0m'

    """
    Returns the output of a shell command and exit status

    Keyword arguments:
    binname -- name of the command executable to run
    args -- arguments for command to run
    """
    def cmd_output(self, binname, args, show_output = False):
        returnstatus = collections.namedtuple('ReturnStatus', ['output', 'status'])

        try:
            binfile = find_executable(binname);
            cmd = [binfile] + args

            try:
                rawout = subprocess.check_output(cmd, stderr=open('/dev/null')).encode("utf-8")
            except AttributeError as e:
                errtext = 'Incorrect pre-commit hook settings: executable does not exist.'
                print(errtext)
                exit(1)

            if show_output == True:
                print(rawout)

            output = rawout.split('\n')
            output = filter(None, output)
            if len(output) == 1:
                output = [output[0]]

            return returnstatus(output, True)
        except subprocess.CalledProcessError as e:
            return returnstatus(e.output, False)

    """Sets the exit status if failure"""
    def cmd_exitstatus(self, rawout):
        if rawout.status == False:
            self.exitstatus = rawout.status

    """Returns tuple containing list of changed staged files and success exit status"""
    def changed_files(self):
        changed = self.cmd_output(
            'git',
            [
                '--no-pager',
                'diff',
                '--name-only',
                '--cached'
            ]
        )

        return changed

    """Decision dialog for warnfile check"""
    def decide(self):
            while True:
                decision = raw_input().lower()
                if decision == 'n':
                    return False
                if decision == '':
                    return False
                elif decision == 'y':
                    return True
                else:
                    print(self.bluebold+'>> Please answer [y/N]:'+self.resetc)
                    return self.decide()

    """Runs the linter as configured in the constructor"""
    def lint_files(self):
        changed = self.changed_files()
        self.cmd_exitstatus(changed)

        checkfiles = [x for x in changed.output if self.lintext in x]

        if checkfiles:
            lintcmd = ' '.join([self.linter]+self.lintargs)
            print(self.bluebold+'>> Running '+lintcmd+' on files:\n'+self.resetc)

            for check in checkfiles:
                cmdargs = self.lintargs + [check]
                linted = self.cmd_output(self.linter, cmdargs)
                if linted.status:
                    color = self.green
                else:
                    color = self.red

                print('\t'+self.linter+': '+color+linted.output.strip('\n')+self.resetc)
                self.cmd_exitstatus(linted)
                print('\n', end='')

    """Looks for files specified to warn for, notifies and sets failure exit status if any are found."""
    def warn_files(self):
        changed = self.changed_files()
        self.cmd_exitstatus(changed)

        warnings = [x for x in self.warnfiles if x in changed.output]

        if warnings:
            print(self.bluebold+'>> You should double check these files before committing:\n'+self.resetc)

            for warning in warnings:
                print('\tfile: '+self.red+warning+self.resetc)

            print(self.bluebold+'\n>> Do you want to continue? [y/N]:'+self.resetc)
            if self.decide() == False:
                self.exitstatus = False

    """Runs the unit test framework as configured in the constructor"""
    def test_files(self):
        print(self.bluebold+'>> Running unit tests...'+self.resetc+'\n')
        if self.testoutput == True:
            tested = self.cmd_output(self.tester, self.testargs, self.testoutput)
        else:
            print(self.bluebold+'>> Running unit tests...'+self.resetc)
            tested = self.cmd_output(self.tester, self.testargs, self.testoutput)
        if tested.status == True:
            print(self.greenbold+'>> Test Success'+self.resetc)
        else:
            print(self.redbold+'>> Test Failure'+self.resetc)

        self.cmd_exitstatus(tested)
        print('\n', end='')

    """Runs the check functions loaded from configuration"""
    def run_checks(self):
        for check in self.checks:
            getattr(self, check)()

def main():
    hookconfig = {
        'warnfiles': [
            'src/test.php',
        ],
        'linter': {
            'executable': 'php',
            'extension': '.php',
            'arguments': [
                '-l'
            ]
        },
        'testing': {
            'executable': 'phpunit',
            'arguments': [
                '-v'
            ],
            'testoutput': True
        },
        'checks': [
            'lint_files',
            'warn_files',
            'test_files'
        ]
    }

    try:
        hook = PreHook(hookconfig)
        hook.run_checks()
        
        if hook.exitstatus == False:
            sys.exit(1)
        elif hook.exitstatus == True:
            sys.exit(0)
    except Exception as e:
        errtext = 'Incorrect pre-commit hook settings:\n{0}: {1!r}'
        errformat = errtext.format(type(e).__name__, e.args)
        print(errformat)
        exit(1)

if __name__ == "__main__":
    main()
